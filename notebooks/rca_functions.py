#import functions --------------------------------
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import scipy.stats as stats
import matplotlib
from scipy.stats import hypergeom
import seaborn as sns
from matplotlib_venn import venn2
from matplotlib_venn import venn3
import ndex2
import networkx as nx
from netcoloc import netprop_zscore
from netcoloc import netprop
from netcoloc import network_colocalization
import re
from scipy.stats import norm
import math
from tqdm import tqdm


# define variables -------------------------------
#pcnet v1.4- used for prior analysis
#pcnet v1.3- used for rat bmi network paper
#pcnet v2.0- not currently available to the public
UUIDs= {
    'pcnet_v14':'c3554b4e-8c81-11ed-a157-005056ae23aa',
    'pcnet_v13':'4de852d9-9908-11e9-bcaf-0ac135e8bacf',
    'string':'98ba6a19-586e-11e7-8f50-0ac135e8bacf',
    'humanNet_v3_FN': '40913318-3a9c-11ed-ac45-0ac135e8bacf',
    'ACN':'29b2d215-07fd-11ef-9621-005056ae23aa',
	'ACN_unannot':'f81a3f67-4215-11ee-aa50-005056ae23aa',
	'ACN_strin':'48de252c-3d50-11ee-aa50-005056ae23aa',
}
UUID_tag={
    'pcnet_v14':'',
    'pcnet_v13':'_pcnet_v13',
    'string':'_string',
    'humanNet_v3_FN': '_humanNet_v3_FN'
}
color_dict={
    'rare':'#25BE93',
    'rare_alt':'#09694e',
    'common':'#C673dc',
    'common_alt':'#642475',
    'shared':'#3636eb',
    'other':'#CCCCCC',
    'SKAT':'#ff03c8',
    'SKAT-O':'#474b96',
    'burden':'#fcba03',
	'Burden':'#fcba03',
    'pLoF':'#fcba03',
    'misLC':'#189B48',
    'syn':'#ff03c8',
    'pLoF_alt':'#af7500',
    'misLC_alt':'#16542d',
    'syn_alt':'#6b0355'
}


def import_seedgenes(path,pcol='P',gene_col='GENE NAME',delim='comma', cutoff=None):
    """
    Imports a list of seed genes from a file and optionally filters them based on p-value criteria. Designed to function with the common_datasets_prepub.csv and rare_datasets_prepub.csv files.

    This function reads a file (either CSV or tab-separated) containing gene data and p-values, and filters the genes based on specified significance thresholds. The function supports filtering by Bonferroni correction or False Discovery Rate (FDR) adjustments.

    Parameters:
    - path (str): The file path to read the gene data from.
    - pcol (str, optional): The name of the column in the file that contains the p-values. If None, no filtering is applied based on p-values. Defaults to 'P'.
    - gene_col (str, optional): The name of the column containing gene names. Defaults to 'GENE NAME'.
    - delim (str, optional): The delimiter type of the file. Accepts 'comma' for CSV files and any other string assumes tab-delimited. Defaults to 'comma'.
    - cutoff (str, optional): The method for adjusting p-values to control for multiple comparisons. Accepts 'bonferroni' for Bonferroni correction, 'FDR' for False Discovery Rate adjustments, or None to apply no cutoff. If None and pcol is not None, all genes are included regardless of p-value.

    Returns:
    DataFrame: A pandas DataFrame of the genes that meet the filtering criteria, if any, including all columns from the input file.

    Notes:
    - Bonferroni correction is calculated as 0.05 divided by the number of observations (genes).
    - FDR correction uses the independent hypothesis method by default. """

    if delim=='comma':
        df=pd.read_csv(path,sep=',')
    else:
        df=pd.read_csv(path,sep='\t')
    if pcol==None:
        print('pvalue column not specified- all genes will be used')
        cutoff=None
    if cutoff=='bonferroni':
        df=df[df[pcol]<0.05/len(df)]
    elif cutoff=='FDR':
        df['pval_FDR']=statsmodels.stats.multitest.fdrcorrection(df[pcol],alpha=0.05,method='indep',is_sorted=False)[1]
        df=df[df['pval_FDR']<0.05]
    else:
        print('cutoff not defined/custom- using all genes ')
        df=df
    print(df.head())
    return(df)

def import_nps_zscores(z_path, interactome_name='pcnet_v14'):
    """
    Imports NPS scores generated from network_prop.ipynb. Designed to work with common_datasets_prepub.csv and rare_datasets_prepub.csv This function is designed to load NPS data for down stream network-based analyses.

    Parameters:
    - z_path (str): The path to the NPS file. The path can be altered dynamically based on the interactome name.
    - interactome_name (str, optional): The name of the interactome to which the z-score data corresponds. If 'pcnet_v14' or None, the file path remains unchanged. Defaults to 'pcnet_v14'.

    Returns:
    DataFrame: A pandas DataFrame containing the z-scores, indexed by the first column of the file and with z-scores labeled under column 'z'.

    Notes:
    - The input file is expected to be tab-separated and without a header row, as generated by network_prop.
    """
    if ((interactome_name=='pcnet_v14')|(interactome_name==None)):
        zscore_rare_df=pd.read_csv(z_path.lower(),header=None, sep='\t')
        print('importing file: '+z_path.lower())
    else:
        z_path_head=z_path[0:len(z_path)-11:1]
        z_path_tail=z_path[len(z_path)-11:len(z_path):1]
        zscore_rare_df=pd.read_csv((z_path_head+'_'+interactome_name+z_path_tail).lower(),header=None, sep='\t')
        print('importing file: '+(z_path_head+'_'+interactome_name+z_path_tail).lower())
    zscore_rare_df.index=zscore_rare_df[0]
    zscore_rare_df=zscore_rare_df.drop(columns=[0])
    zscore_rare=zscore_rare_df[1].squeeze()
    zscore_rare_df = pd.DataFrame({'z':zscore_rare})
    print(zscore_rare_df.head())
    return(zscore_rare_df)

def import_interactome(interactome_name=None, UUIDs=UUIDs,ndex_user=None, ndex_password=None, UUID=None):
    """
    Imports a gene interactome from the NDEx database and returns it as a NetworkX graph object.
    Optionally, the function allows for importing using a unique identifier (UUID) or by an interactome name.
    
    Parameters:
    - interactome_name (str, optional)
	- UUIDs (str,optional): dictionary of UUIDs
    - ndex_user (str, optional)
    - ndex_password (str, optional)
    - UUID (str, optional)

    Returns:
    networkx.Graph: A graph object representing the interactome.
    
    Raises:
    - ValueError: If neither an interactome name nor a UUID is provided.
    """
    
    ndex_server = 'public.ndexbio.org'
    # import network based on provided interactome key
    if interactome_name in UUIDs.keys():
        interactome_uuid = UUIDs[interactome_name]
        print(interactome_name)
        graph = ndex2.create_nice_cx_from_server(
            ndex_server, 
            username=ndex_user, 
            password=ndex_password, 
            uuid=interactome_uuid
        ).to_networkx()
        if interactome_name == 'pcnet_v14':
            graph = nx.relabel_nodes(graph, nx.get_node_attributes(graph, 'HGNC Symbol'))
        
        # print out interactome num nodes and edges for diagnostic purposes
        print('number of nodes:')
        print(len(graph.nodes))
        print('\nnumber of edges:')
        print(len(graph.edges))
        return graph

    elif interactome_name is None and UUID is not None:
        print('using novel UUID. For UUIDs used in this study, see UUIDs')
        graph = ndex2.create_nice_cx_from_server(
            ndex_server, 
            username=ndex_user, 
            password=ndex_password, 
            uuid=UUID
        ).to_networkx()
        
        # print out interactome num nodes and edges for diagnostic purposes
        print('number of nodes:')
        print(len(graph.nodes))
        print('\nnumber of edges:')
        return graph

    else:
        print('UUID/interactome name not provided- please provide either to import interactome.')


# network formatting functions
def format_network(network, traitr, traitc, seedr, seedc,zr, zc):
    """
    Formats the colocalized network for easy secondary analysis in Cytoscape
    This function takes a network (graph) and updates its nodes with several attributes:
    - Seed gene indicators for two traits with secondary "color scheme" indicator for use in cytoscape color scheme assignment
    - Z-scores for each trait and their combination

    Parameters:
    - network (NetworkX graph): The graph to be formatted, where nodes represent genes.
    - traitr (str): Identifier for the rare trait.
    - traitc (str): Identifier for the common trait.
    - seedr (list): List of seed genes associated with the rare trait.
    - seedc (list): List of seed genes associated with the common trait.
    - zr (dict): Dictionary mapping genes to their z-scores for the rare trait.
    - zc (dict): Dictionary mapping genes to their z-scores for the common trait.

    Returns:
    - NetworkX graph: The original network updated with node attributes for seed gene status and z-scores for traits and their combination.

    Note:
    The function utilizes pandas DataFrames for intermediate data manipulation and requires 
    NetworkX for working with the network. It expects `network.nodes()` to return a list-like 
    object of genes.
    """
    nodes_df=pd.DataFrame(network.nodes())
    nodes_df.columns=['Gene']
    #make node seed gene dataframe from which to make dictionaries
    nodes_df[('seed_'+traitr)]=nodes_df['Gene'].isin(seedr)
    nodes_df[('seed_'+traitc)]=nodes_df['Gene'].isin(seedc)
    nodes_df['seed_both']=(nodes_df['Gene'].isin(seedr) & nodes_df['Gene'].isin(seedc))
    
    nodes_df['color_scheme']=0
    nodes_df['color_scheme'] = np.where(nodes_df[('seed_'+traitr)] == True, 1, nodes_df['color_scheme'])
    nodes_df['color_scheme'] = np.where(nodes_df[('seed_'+traitc)] == True, 2, nodes_df['color_scheme'])
    nodes_df['color_scheme'] = np.where((nodes_df["seed_both"] == True), 3, nodes_df['color_scheme'])    
    nodes_df.index=nodes_df['Gene']
    #set zscores as node attributes
    nx.set_node_attributes(network, dict(zr), ('z_'+traitr))
    nx.set_node_attributes(network, dict(zc),('z_'+traitc))
    nx.set_node_attributes(network, dict(zr*zc), 'z_comb')
    #add seed genes as node attributes
    nx.set_node_attributes(network,dict(zip(nodes_df['Gene'], nodes_df[('seed_'+traitr)])), ('seed_'+traitr))
    nx.set_node_attributes(network,dict(zip(nodes_df['Gene'], nodes_df[('seed_'+traitc)])), ('seed_'+traitc))
    nx.set_node_attributes(network,dict(zip(nodes_df['Gene'], nodes_df['seed_both'])), ('seed_both'))
    nx.set_node_attributes(network,dict(zip(nodes_df['Gene'], nodes_df['color_scheme'])), ('seed_color_scheme'))
    return(network)
    
def export_network(network, name, user, password, ndex_server='public.ndexbio.org'):
    '''
    shell for net_cx upload network function, that creates nicecx network, then exports to NDEx in the CX format.

    This function converts a NetworkX graph to a NiceCXNetwork object using the ndex2 Python package,
    sets the network's name, and uploads it to the specified NDEx server. Upon successful upload, 
    the function returns the UUID of the network in the NDEx platform.

    Parameters:
    - network (NetworkX graph): The graph to be exported.
    - name (str): The name to assign to the network in NDEx.
    - user (str): NDEx account username.
    - password (str): NDEx account password.
    - ndex_server (str, optional): The URL of the NDEx server to which the network is to be uploaded. Defaults to 'public.ndexbio.org'.

    Returns:
    - exports network to NDEx
    - str: The UUID of the uploaded network on NDEx.
    Notes:
    Tequires the ndex2 package. Ensure that you have a valid NDEx account and that the specified server URL is correct.
    """
    '''
    print(user)
    print(password)
    if ((user==None) | (password==None)):
        print('please provide a NDEx username and password.')
    else:
        net_cx = ndex2.create_nice_cx_from_networkx(network)
        net_cx.set_name(name)
        network_uuid = net_cx.upload_to(ndex_server, user, password)

        
def combine_nps_table(tblr, tblc):
    tbl_z=pd.concat([tblr, tblc], axis=1)
    tbl_z.columns=('z1','z2')
    tbl_z['z_comb']=tbl_z['z1']*tbl_z['z2']
    tbl_z.columns=['NPSr','NPSc','NPScr']
    return(tbl_z)

	
def NPS_lineplot(df,metric, filename, xrange=None, yrange=None, savefig=False, sigline=False):
    matplotlib.rcParams.update({'font.size': 8})
    df['-log10(p)']=-np.log10(df['empirical_p'])

    # Group data by NPS_single and plot each group separately
    groups = df.groupby('NPS_single')
    
    # Initialize a plot
    fig, ax = plt.subplots(figsize=(2.75, 2))
    
    # Plot lines for each NPS_single group
    for name, group in groups:
        ax.plot(group['NPS_common-rare'], group[metric], marker='o', label=f'NPS_single={name}')
    if sigline:
	    ax.axhline(y =-np.log10(0.05/len(df)), color = 'red', linestyle = 'dashed', linewidth=1)
    if ~(yrange is None):
        ax.set_ylim(yrange)
    if ~(xrange is None):
        ax.set_xlim(xrange)    
    # Set plot labels
    ax.set_xlabel('NPS combined') 
    ax.set_ylabel(metric.replace('_',' '))
    ax.legend(title='NPS single')
    ax.grid(True)
    ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    if savefig:
        plt.savefig('figures/'+filename,bbox_inches='tight')
    plt.show()
#adapted from CrossSpeciesBMI github: https://github.com/sarah-n-wright/CrossSpeciesBMI --------------------------------------------------------------------

def venn_net(tblr, tblc, tblr_label, tblc_label, p_net_overlap,tblr_lim=1.5, tblc_lim=1.5, comb_lim=3, savefig=False):
    """
    Generates and displays a Venn diagram visualizing the overlap between network implicated genes based calculated NPSrare and NPScommon.

    This function combines two tables of z-scores, filters entries based on network limits, and then visualizes the overlap between them in a Venn diagram. Additional metadata and network parameters are displayed in the diagram's title. Optionally, the diagram can be saved as an SVG file.

    Parameters:
    - tblr (DataFrame): A pandas DataFrame containing NPSrare.
    - tblc (DataFrame): A pandas DataFrame containing NPScommon.
    - tblr_label (str): Label for the rare trait, used in the Venn diagram.
    - tblc_label (str): Label for the common trait, used in the Venn diagram.
    - p_net_overlap (float): A probability or statistical value associated with the network overlap, shown in the plot title.
    - tblr_lim (float, optional): The NPSrare cutoff. Defaults to 1.5.
    - tblc_lim (float, optional): The NPScommon cutoff. Defaults to 1.5.
    - comb_lim (float, optional): The NPScommon-rare. Defaults to 3.
    - savefig (bool, optional): If True, saves the plot as an SVG file in a predefined directory. Defaults to False.

    Returns:
    None
    """
    print(tblr_lim)
    #combine zscore tables
    tbl_z=combine_nps_table(tblr, tblc)
    #subset table to those within network limit parameters
    inNetwork=tbl_z[(tbl_z['NPSr']>tblr_lim) & (tbl_z['NPSc']>tblc_lim) & (tbl_z['NPScr']>comb_lim)]
    print(len(inNetwork))
    #plot venn diagram
    Nr=(len(tbl_z[tbl_z['NPSr']>tblr_lim])-len(inNetwork))
    Nc=(len(tbl_z[tbl_z['NPSc']>tblc_lim])-len(inNetwork))
    Nboth=len(inNetwork)
    venn2((Nr,Nc,Nboth), 
		  set_labels=(tblr_label, tblc_label),
      set_colors=(color_dict['rare'], color_dict['common']), alpha = 0.7)
    plt.title('p='+str(p_net_overlap)+ ', single cut='+str(tblr_lim)+', comb cut='+str(comb_lim))
    if savefig:
        plt.savefig('figures/network_venn_'+tblr_label+'_'+tblc_label+'.svg',bbox_inches='tight')
    plt.show()
    
def venn_seeds(tblr_seed, tblc_seed, tblr_label, tblc_label, all_nodes, savefig=False):
    """
    Generates and displays a Venn diagram visualizing the overlap between seed genes from two lists within a given set of nodes.

    This function filters seed genes from two lists to ensure they are within a specified set of nodes, calculates the overlap between these filtered lists, and visualizes this overlap in a Venn diagram. The significance of the overlap is calculated using a hypergeometric test, similarly to methodologies used in specific scientific literature. Optionally, the diagram can be saved as an SVG file.

    Parameters:
    - tblr_seed (list of str): A list of rare seed genes.
    - tblc_seed (list of str): A list of common seed genes.
    - tblr_label (str): Label for rare trait, used in the Venn diagram.
    - tblc_label (str): Label for common trait, used in the Venn diagram.
    - all_nodes (set): A set of all possible nodes within which the seeds should be filtered. Typically this is all nodes in PCNet. 
    - savefig (bool, optional): If True, saves the plot as an SVG file in a predefined directory. Defaults to False.

    Returns:
    None
    """
    tblr_seed=list(set(tblr_seed).intersection(all_nodes))
    tblc_seed=list(set(tblc_seed).intersection(all_nodes))  
    #define overlap for seed genes plot
    seed_overlap=set(tblr_seed).intersection(set(tblc_seed))
    print(seed_overlap)
    #compute significance of seed genes overlap- same test as used in BMI paper
    hyper = hypergeom(M=len(all_nodes), n=len(tblr_seed), N=len(tblc_seed))
    p_intersect_seed = hyper.sf(len(seed_overlap))
    
    venn2((len(tblr_seed)-len(seed_overlap), len(tblc_seed)-len(seed_overlap), len(seed_overlap)), 
          set_labels=(tblr_label, tblc_label), 
          set_colors=(color_dict['rare'], color_dict['common']), alpha = 0.7)
    plt.title(' Seed Gene Overlap, p='+str(p_intersect_seed))
    if (savefig):
        plt.savefig('figures/seed_venn_'+tblr_label+'_'+tblc_label+'.svg',bbox_inches='tight')
    plt.show()


def plt_histogram (tblr, tblc, tblr_label, tblc_label, tblr_seed, tblc_seed, tblr_lim=1.5, tblc_lim=1.5, comb_lim=3, savefig=False):
    """
    Visualizes the NPScommon and NPSrare scores as histograms and as a scatter plot

    The function generates four plots in a single figure: two histograms of NPScommon and NPS rare with and without seed genes, a combined histogram of NPScommon-rare, and a scatter plot of combined scores with network threshold lines, where NPSrare is plotted on the x-axis and NPScommon is plotted on the y-axis.

    Parameters:
    - tblr (DataFrame): DataFrame containing NPSrare.
    - tblc (DataFrame): DataFrame containing NPScommon.
    - tblr_label (str): Label for rare trait, used in the Venn diagram.
    - tblc_label (str): Label for common trait, used in the Venn diagram.
    - tblr_seed (list of str): A list of rare seed genes.
    - tblc_seed (list of str): A list of common seed genes.
    - tblr_lim (float, optional): The NPSrare cutoff. Defaults to 1.5.
    - tblc_lim (float, optional): The NPScommon cutoff. Defaults to 1.5.
    - comb_lim (float, optional): The NPScommon-rare. Defaults to 3.
    - savefig (bool, optional): If True, saves the plot as an SVG file in a predefined directory. Defaults to False.

    Returns:
    None
    """
    fig, [ax1, ax2, ax3, ax4] = plt.subplots(nrows=1, ncols=4, figsize=(25, 5))
    _, bins, _ = ax1.hist(tblr, bins=100, alpha=0.7, density=True, label=tblr_label, color=color_dict['rare'])
    _ = ax1.hist(tblc, bins=bins, alpha=0.7, density=True, label=tblc_label, color=color_dict['common'])
    ax1.set_ylabel("density")
    ax1.set_xlabel("proximity zscore")
    ax1.legend()

    _, bins, _ = ax2.hist(tblr[~tblr.index.isin(tblr_seed)], bins=100, alpha=0.7, density=True, label=tblr_label,color=color_dict['rare'] )
    _ = ax2.hist(tblc[~tblc.index.isin(tblc_seed)], bins=bins, alpha=0.7, density=True, label=tblc_label, color=color_dict['common'])
    ax2.set_ylabel("density")
    ax2.set_xlabel("proximity zscore (no seed genes)")
    ax2.legend()
    
    _, bins, _ = ax3.hist(tblc['z']*tblr['z'], bins=bins, alpha=0.7, density=True, label='combined score', color=color_dict['shared'])
    ax3.set_xlabel("Combined proximity zscore")
    ax3.set_ylabel("density")
    
    #combine zscore tables
    tbl_z=pd.concat([tblr, tblc], axis=1)
    tbl_z.columns=('z1','z2')
    tbl_z['z_comb']=tbl_z['z1']*tbl_z['z2']
    inNetwork=tbl_z[(tbl_z['z1']>tblr_lim) & (tbl_z['z2']>tblc_lim) & (tbl_z['z_comb']>comb_lim)]
    outNetwork=tbl_z[(tbl_z['z1']<=tblr_lim) | (tbl_z['z2']<=tblc_lim) | (tbl_z['z_comb']<=comb_lim)]
    
    ax4.scatter(x=outNetwork['z1'], y=outNetwork['z2'], s=1, color=color_dict['other'])
    ax4.scatter(x=inNetwork['z1'], y=inNetwork['z2'], s=1, color=color_dict['shared'])
        
    ax4 = plt.xlabel(tblr_label)
    
    plt.ylabel(tblc_label)
    plt.axvline(x = tblr_lim, color=color_dict['rare'], linestyle = 'dashed', linewidth=1)
    plt.axhline(y = tblc_lim, color = color_dict['common'], linestyle = 'dashed', linewidth=1)
    x_points = [(i+0.0001)/10 for i in range(-50,250)]
    combo_line = [comb_lim/x for x in x_points if x > comb_lim/50]
    plt.plot([x for x in x_points if x > comb_lim/40], combo_line, color=color_dict['shared'], linestyle='dashed',linewidth=1)
    plt.axvline(x = 0, color='black', linestyle = 'solid', linewidth=1)
    plt.axhline(y = 0, color = 'black', linestyle = 'solid', linewidth=1)
    if (savefig):
        plt.savefig('figures/histogram_'+tblr_label+'_'+tblc_label+'.svg',bbox_inches='tight')
    plt.show()

#non-network functions - manhattan and sorted_nicely modified from CrossSpeciesBMI experimental notebooks github: https://github.com/sarah-n-wright/CrossSpeciesBMI-----------------

def sorted_nicely(l):
    """
    Helper function for porcupine and manhattan to sort chromosomes. Sorts a list in a human-friendly way where numerical values embedded in strings are sorted numerically.
    
    It uses a natural sorting algorithm, where digits in strings are converted to integers for comparison during sorting to circumvent ASCII value-based sorting. 

    Parameters:
    - l (list of str): A list of strings to be sorted.

    Returns:
    list: Alphanumerically sorted list.

    Notes:
    - The function does not handle cases where non-unicode numeric representations (like Roman numerals) are involved.
    - Strings are assumed to be ASCII or Unicode and cases where binary or non-text data are involved are not handled.
    """

    convert = lambda text: int(text) if text.isdigit() else text
    alphanum_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ]
    return sorted(l, key = alphanum_key)

def manhattan(pval, pos, chr, label,
              chrs_plot=None, chrs_names=None,
              cut=2,
              colors=['k', '0.5'],
              title='Title',
              xlabel='chromosome',
              ylabel='-log10(p-value)',
              top=0,
              lines=[10, 15],
              lines_colors=['g', 'r'],
              lines_styles=['-', '--'],
              lines_widths=[1, 1],
              zoom=None,
              scaling='-log10',
              plot_grid_lines=True,
              **kwargs):
    """
    Creates a Manhattan plot across chromosomes based on their p-values.

    Parameters:
    - pval (array-like): List or array of p-values for genomic variants.
    - pos (array-like): Corresponding positions of the variants on their respective chromosomes.
    - chr (array-like): Chromosome numbers for each variant.
    - label (str): Label for the dataset, used for plotting and legend.
    - chrs_plot (list, optional): Specific chromosomes to include in the plot; defaults to plotting all unique chromosomes.
    - chrs_names (list, optional): Names to be displayed along the x-axis for chromosomes; automatically generated if not provided.
    - cut (float): Cutoff value for -log10(p-values) to display; variants below this value are not plotted.
    - colors (list): Colors to use for plotting points, alternating between chromosomes.
    - title (str): Title of the plot.
    - xlabel (str): Label for the x-axis.
    - ylabel (str): Label for the y-axis, indicating the transformation applied to p-values.
    - top (float): Maximum value for the y-axis; calculated from data if not provided.
    - lines (list): List of y-values where horizontal lines should be drawn.
    - lines_colors (list): Colors for each horizontal line listed in 'lines'.
    - lines_styles (list): Line styles for each horizontal line.
    - lines_widths (list): Widths of each horizontal line.
    - zoom (tuple): Tuple (chromosome, center position, range) defining a zoom region on a specific chromosome.
    - scaling (str): Method of scaling p-values; options are '-log10' for negative log-transform or 'none' for raw p-values.
    - plot_grid_lines (bool): Whether to draw grid lines at chromosome boundaries.
    - **kwargs: Additional keyword arguments passed to the plt.plot function.

    Returns:
    matplotlib.pyplot: Configured plot object ready to be shown or saved.
    """
    # Generate figure
    shift = np.array([0.0])
    plt.clf()

    # Generate list of chromosomes for chr_plot from chr if chr_plot doesn't exist
    if chrs_plot is None:
        chrs_list = np.unique(chr)
        if isinstance(chrs_list[0], str):
            chrs_list = sorted_nicely(chrs_list)  # Assuming sorted_nicely is defined elsewhere
        else:
            chrs_list.sort()
    # Create labels from chr for chromosomes if not provided
    if chrs_names is None:
        chrs_names = [str(chrs_list[i]) for i in range(len(chrs_list))]

    # Iteratively plot each chromosome's data
    plot_positions = len(chrs_list) == 1
    for ii, i in enumerate(chrs_list):
        plt.subplot(1, 1, 1)
        filt = np.where(chr == i)[0]
        x = shift[-1] + pos[filt]
        y = -np.log10(pval[filt]) if scaling == '-log10' else pval[filt]
        plt.plot(x[y > cut], y[y > cut], '.', color=colors[ii % len(colors)], **kwargs)
        shift_f = np.max(x)

        # Apply zoom if specified
        zoom_shift = zoom[1] + shift[-1] if zoom is not None and zoom[0] == i else 0
        shift = np.append(shift, np.max([shift_f, 0]))
        #add gridlines to figure
        if plot_grid_lines:
            plt.plot([shift[-1], shift[-1]], [0, 1000], '-', lw=0.5, color='lightgray', **kwargs)
            plt.xlim([0, shift[-1]])

    # Adjust top boundary of the plot
    if top == 0:
        top = np.ceil(np.max(-np.log10(pval))) if scaling == '-log10' else np.ceil(np.max(pval))

    # Set labels and plot horizontal lines
    shift_label = shift[-1]
    shift = (shift[1:] + shift[:-1]) / 2
    for i, y in enumerate(lines):
        plt.axhline(y=y, color=lines_colors[i], linestyle=lines_styles[i], linewidth=lines_widths[i])

    # Final plot adjustments
    plt.ylim([cut, top])
    plt.title(title)
    if not plot_positions:
        plt.xticks(shift, chrs_names)
    plt.text(shift_label * 0.95, top * 0.95, label,
             verticalalignment='top', horizontalalignment='right')
    plt.ylabel(ylabel)
    plt.xlabel(xlabel)

    # Apply zoom if specified
    if zoom is not None:
        plt.xlim([zoom_shift - zoom[2], zoom_shift + zoom[2]])

    return plt


def porcupine(pval, test, pos, chr, label,
              cut_SKAT=5e-8,
              cut_SKATO=5e-8,
              cut_burden=5e-8,
              chrs_plot=None, chrs_names=None,
              cut=2,
              colors=['k', '0.5'],
              title='Title',
              xlabel='chromosome',
              ylabel='-log10(p-value)',
              top=0,
              lines=[10, 15],
              lines_colors=['g', 'r'],
              lines_styles=['-', '--'],
              lines_widths=[1, 1],
              zoom=None,
              scaling='-log10',
              plot_grid_lines=True,
              **kwargs):
    """
    Generates a specialized Porcupine plot for different types of rare-variant SNP to gene tests (SKAT, SKATO, Burden), highlighting significant findings in genomic data using color-coding for test types.

    Parameters:
    - pval (array-like): Array of p-values for genomic variants.
    - test (array-like): Array specifying the type of genetic test performed for each variant p-value.
    - pos (array-like): Array of positions of variants on their respective chromosomes.
    - chr (array-like): Array of chromosome numbers for each variant.
    - label (str): Label for the dataset, used for annotations.
    - cut_SKAT, cut_SKATO, cut_burden (float): Cutoff p-values for SKAT, SKATO, and Burden tests, respectively.
    - chrs_plot (list, optional): Specific chromosomes to include in the plot.
    - chrs_names (list, optional): Custom names for the chromosomes to be plotted.
    - cut (float): Cutoff for -log10(p-value) for displaying points on the plot.
    - colors (list): Colors to use for plotting points, cycling through for different chromosomes.
    - title (str): Title of the plot.
    - xlabel, ylabel (str): Labels for the x-axis and y-axis.
    - top (float): Upper limit for the y-axis; if 0, it is calculated from the data.
    - lines (list): y-values where horizontal lines should be drawn.
    - lines_colors, lines_styles, lines_widths (list): Properties for the horizontal lines.
    - zoom (tuple): Tuple (chromosome, center position, range) for focusing on a specific region.
    - scaling (str): P-value scaling method; supports '-log10' for negative log transformation or 'none'.
    - plot_grid_lines (bool): Whether to include grid lines on the plot.
    - **kwargs: Additional keyword arguments for matplotlib plot functions.

    Returns:
    matplotlib.pyplot: Configured plot object ready for display or saving.
    """
    
    # Initialize plot settings and clear any existing figures
    shift = np.array([0.0])
    plt.clf()

    # Determine which chromosomes to plot, sorting naturally if needed
    if chrs_plot is None:
        chrs_list = np.unique(chr)
        chrs_list = sorted_nicely(chrs_list) if isinstance(chrs_list[0], str) else chrs_list.sort()
    else:
        chrs_list = chrs_plot

    # Generate chromosome labels if not provided
    if chrs_names is None:
        chrs_names = [str(chrs_list[i]) for i in range(len(chrs_list))]

    plot_positions = len(chrs_list) == 1

    # Convert cutoffs to the appropriate scale if necessary
    if scaling == '-log10':
        cut_burden = -np.log10(cut_burden)
        cut_SKATO = -np.log10(cut_SKATO)
        cut_SKAT = -np.log10(cut_SKAT)
        
    # Plot data for each chromosome
    for ii, i in enumerate(chrs_list):     
        plt.subplot(1,1,1)
        filt = np.where(chr == i)[0]
        x = shift[-1] + pos[filt]
        y = -np.log10(pval[filt]) if scaling == '-log10' else pval[filt]
        test_filter = test[filt]
        
        # Plot data points above a general cut-off, with specific colors for each test type. Requires the color_dict to function, or must redefine the color dictionary
        plt.plot(x[y > cut], y[y > cut], '.', color=colors[ii % len(colors)], **kwargs)
        plt.plot(x[(y > cut) & (test_filter == 'Burden') & (y > cut_burden)], y[(y > cut) & (test_filter == 'Burden') & (y > cut_burden)], '.', color=color_dict['Burden'], **kwargs)
        plt.plot(x[(y > cut) & (test_filter == 'SKATO') & (y > cut_SKATO)], y[(y > cut) & (test_filter == 'SKATO') & (y > cut_SKATO)], '.', color=color_dict['SKAT-O'], **kwargs)
        plt.plot(x[(y > cut) & (test_filter == 'SKAT') & (y > cut_SKAT)], y[(y > cut) & (test_filter == 'SKAT') & (y > cut_SKAT)], '.', color=color_dict['SKAT'], **kwargs)

        # Calculate the maximum shift for the next set of points
        shift_f = np.max(x)
        shift_m = 0  # Placeholder for potential future use
        shift = np.append(shift, np.max([shift_f, shift_m]))

        # Set grid lines and limits
        if plot_grid_lines:
            plt.plot([shift[-1], shift[-1]], [0, 1000], '-', lw=0.5, color='lightgray', **kwargs)
        plt.xlim([0, shift[-1]])

    # Determine the upper limit for the y-axis
    if top == 0:
        top = np.ceil(np.max(-np.log10(pval))) if scaling == '-log10' else np.ceil(np.max(pval))

    # Configure fig labels and horizontal lines
    shift_label = shift[-1]
    shift = (shift[1:] + shift[:-1]) / 2
    for i, line_height in enumerate(lines):
        plt.axhline(y=line_height, color=lines_colors[i], linestyle=lines_styles[i], linewidth=lines_widths[i])
    
    plt.ylim([cut, top])
    plt.title(title)
    if not plot_positions:
        plt.xticks(shift, chrs_names)
    plt.text(shift_label * 0.95, top * 0.95, label, verticalalignment='top', horizontalalignment='right')
    plt.ylabel(ylabel)
    plt.xlabel(xlabel)

    # Apply zoom settings if specified
    if zoom is not None:
        plt.xlim([zoom_shift - zoom[2], zoom_shift + zoom[2]])

    return plt


## Extensions to NetColoc from CrossSpeciesBMI github: https://github.com/sarah-n-wright/CrossSpeciesBMI --------------------------------------------------------------------

def plot_permutation_histogram(permuted, observed, title="", xlabel="Observed vs Permuted", color='#CCCCCC', arrow_color="blue",savefig=False, filename=None):
    """Plot an observed value against a distribution of permuted values. Adapted from BMI

    Args:
        permuted (list): A list of permuted values that form the distribution
        observed (float): The observed value of interest
        title (str): Plot title. Defaults to "".
        xlabel (str): The x axis title. Defaults to "Observed vs Permuted".
        color (str, optional): The color of the histogram. Defaults to "cornflowerblue".
        arrow_color (str, optional): The color of the arrow pointing to observed value. Defaults to "red".
    """
    plt.figure(figsize=(4, 4))
    dfig = sns.histplot(permuted, label='Permuted', alpha=0.4, stat='density', bins=25, kde=True, 
                        edgecolor='w', color=color)
    params = {'mathtext.default': 'regular'}          
    plt.rcParams.update(params)
    plt.xlabel(xlabel, fontsize=16)
    diff = max(observed, max(permuted))-min(permuted)
    plt.arrow(x=observed, y=dfig.dataLim.bounds[3]/2, dx=0, dy=-1 * dfig.dataLim.bounds[3]/2, label="Observed",
              width=diff/100, head_width=diff/15, head_length=dfig.dataLim.bounds[3]/20, overhang=0.5, 
              length_includes_head=True, color=arrow_color, zorder=50)
    plt.ylabel("Density", fontsize=16)
    plt.legend(fontsize=12, loc=(0.6,0.75))
    plt.xticks(fontsize=12)
    plt.yticks(fontsize=12)
    plt.locator_params(axis="y", nbins=6)
    plt.title(title + " (p=" + str(get_p_from_permutation_results(observed, permuted)) + ")", fontsize=16)
    
    if savefig:
        plt.savefig('figures/' + filename + '.svg', bbox_inches='tight')

def get_p_from_permutation_results(observed, permuted):
    """Calculates the significance of the observed mean relative to the empirical normal distribution of permuted means.

    Args:
        observed (float): The observed value to be tested
        permuted (list): List of values that make up the expected distribution
    
    Returns:
        float: p-value from z-test of observed value versus the permuted distribution
    """
    p = norm.sf((observed - np.mean(permuted)) / np.std(permuted))
    try:
        p = round(p, 4 - int(math.floor(math.log10(abs(p)))) - 1)
    except ValueError:
        print("Cannot round result, p=", p)
    return p

def calculate_mean_z_score_distribution(z1, z2, num_reps=1000, zero_double_negatives=True, 
                                        overlap_control="remove", seed1=[], seed2=[]):
    """Determines size of expected mean combined `z=z1*z2` by randomly shuffling gene names

    Args:
        z1 (pd.Series, pd.DataFrame): Vector of z-scores from network propagation of trait 1
        z2 (pd.Series, pd.DataFrame): Vector of z-scores from network propagation of trait 2
        num_reps (int): Number of perumation analyses to perform. Defaults to 1000
        zero_double_negatives (bool, optional): Should genes that have a negative score in both `z1` and `z2` be ignored? Defaults to True.
        overlap_control (str, optional): 'bin' to permute overlapping seed genes separately, 'remove' to not consider overlapping seed genes. Any other value will do nothing. Defaults to "remove".
        seed1 (list, optional): List of seed genes used to generate `z1`. Required if `overlap_control!=None`. Defaults to [].
        seed2 (list, optional): List of seed genes used to generate `z2`. Required if `overlap_control!=None`. Defaults to [].

    Returns:
        float: The observed mean combined z-score from network colocalization
        list: List of permuted mean combined z-scores
    """
    if isinstance(z1, pd.Series):
        z1 = pd.DataFrame(z1, columns=["z"])
    if isinstance(z2, pd.Series):
        z2 = pd.DataFrame(z2, columns=["z"])
    z1z2 = z1.join(z2, lsuffix="1", rsuffix="2")
    z1z2 = z1z2.assign(zz=z1z2.z1 * z1z2.z2)
    #print(z1z2.head())
    if overlap_control == "remove":
        seed_overlap = list(set(seed1).intersection(set(seed2)))
        print("Overlap seed genes:", len(seed_overlap))
        z1z2.drop(seed_overlap, axis=0, inplace=True)
    elif overlap_control == "bin":
        seed_overlap = list(set(seed1).intersection(set(seed2)))
        print("Overlap seed genes:", len(seed_overlap))
        overlap_z1z2 = z1z2.loc[seed_overlap]
        overlap_z1 = np.array(overlap_z1z2.z1)
        z1z2.drop(seed_overlap, axis=0, inplace=True)
    z1 = np.array(z1z2.z1)
    z2 = np.array(z1z2.z2)
    if zero_double_negatives:
        for node in z1z2.index:
            if (z1z2.loc[node].z1 < 0 and z1z2.loc[node].z2 < 0):
                z1z2.loc[node, 'zz'] = 0
    permutation_means = np.zeros(num_reps)
    for i in tqdm(range(num_reps)):
        perm_z1z2 = np.zeros(len(z1))
        np.random.shuffle(z1)

        for node in range(len(z1)):
            if not zero_double_negatives or not (z1[node] < 0 and z2[node] < 0):
                perm_z1z2[node] = z1[node] * z2[node]
            else:
                perm_z1z2[node] = 0
        if overlap_control == "bin":
            overlap_perm_z1z2 = np.zeros(len(overlap_z1))
            np.random.shuffle(overlap_z1) 
            for node in range(len(overlap_z1)):
                if zero_double_negatives and (overlap_z1[node] < 0 and z2[node] < 0):
                    overlap_perm_z1z2[node] = 0
                else:
                    overlap_perm_z1z2[node] = overlap_z1[node] * z2[node]
            perm_z1z2 = np.concatenate([perm_z1z2, overlap_perm_z1z2])
                    
        permutation_means[i] = np.mean(perm_z1z2)
    return np.mean(z1z2.zz), permutation_means

def f_test(group1, group2):
    """
    Performs an F-test to compare the variances of two independent samples.

    This function calculates the F-statistic to determine if there are any significant differences between the variances of two groups. 
    The F-statistic is calculated as the ratio of the variances of the two groups. The function also computes the p-value associated with the 
    F-statistic under the assumption that both groups are normally distributed.

    Parameters:
    - group1 (array-like): Numeric data representing the first group or sample.
    - group2 (array-like): Numeric data representing the second group or sample.

    Returns:
    tuple:
    - float: The computed F-statistic.
    - float: The p-value corresponding to the F-statistic, derived from the F-distribution.
    """
    f = np.var(group1, ddof=1)/np.var(group2, ddof=1)
    nun = np.array(group1).size-1
    dun = np.array(group2).size-1
    p_value = 1-stats.f.cdf(f, nun, dun)
    return f, p_value

## FUNCTIONS FOR VALIDATING FROM THE GWAS CATALOG--------------------------
def format_catalog(catalog=None):
	"""
	Processes and formats the GWAS catalog associations DataFrame by standardizing gene and trait names, 
	filtering relevant entries, and organizing data for easier querying and analysis.

	This function performs several operations to prepare GWAS catalog data for analysis:
	1. Converts 'MAPPED_TRAIT' and 'DISEASE/TRAIT' to lowercase for consistent querying.
	2. Filters out entries without mapped genes or traits.
	3. Splits gene entries that contain multiple genes listed together.
	4. Removes intergenic regions and entries labeled as 'mapped'.
	5. Combines trait information into a single column with PubMed ID references.

	Parameters:
	- catalog (DataFrame): A pandas DataFrame containing GWAS catalog data. If not provided, the function attempts to process, but will likely fail silently within the try-except block.

	Returns:
	DataFrame: A formatted DataFrame with each gene associated with its traits and citations.

	Raises:
	- Prints an error message if the input catalog is None or processing fails due to other issues.

	Notes:
	- This function assumes the input DataFrame contains specific columns: 'MAPPED_GENE', 'REPORTED GENE(S)', 'MAPPED_TRAIT', 'DISEASE/TRAIT', and 'PUBMEDID'.
	- The output DataFrame consolidates trait information into a single 'TRAIT' column and normalizes gene names.
	"""
	try:
		#make all annotations lowercase for consistency for querying
		catalog['MAPPED_TRAIT']=catalog['MAPPED_TRAIT'].str.lower()
		catalog['DISEASE/TRAIT']=catalog['DISEASE/TRAIT'].str.lower()
		#filter for genes that were mapped
		mapped=catalog[~catalog['MAPPED_GENE'].isna()]
		mapped=mapped[~mapped['MAPPED_TRAIT'].isna()]
		mapped=mapped[['MAPPED_GENE','MAPPED_TRAIT','DISEASE/TRAIT','PUBMEDID']]
		mapped.columns=['GENE','MAPPED_TRAIT','DISEASE/TRAIT','PUBMEDID']
		#filter for genes that were reported
		rep=catalog[~catalog['REPORTED GENE(S)'].isna()]
		rep=rep[~rep['MAPPED_TRAIT'].isna()]
		rep=rep[~rep['REPORTED GENE(S)'].str.contains('Intergenic')]
		rep=rep[['REPORTED GENE(S)','MAPPED_TRAIT','DISEASE/TRAIT','PUBMEDID']]
		rep.columns=['GENE','MAPPED_TRAIT','DISEASE/TRAIT','PUBMEDID']
		cat=pd.concat([rep, mapped])
		cat['GENE']=cat['GENE'].str.split('; ')
		cat=cat.explode('GENE')
		cat=cat[~(cat['GENE'].str.contains('mapped'))]
		cat['GENE']=cat['GENE'].str.split(', ')
		cat=cat.explode('GENE')
		cat['GENE']=cat['GENE'].str.split(' - ')
		cat=cat.explode('GENE')
		cat['GENE']=cat['GENE'].astype('str')
		cat=cat[~(cat['GENE'].str.contains('intergenic'))]
		cat['TRAIT']=cat['MAPPED_TRAIT'] + ": " +cat['DISEASE/TRAIT']+ " (PMID: "+(cat['PUBMEDID'].astype(str))+")"
		cat=cat.dropna()
		return(cat)
	except:
		print('please add gwas catalog file.')
def subset_catalog(cat=None, trait_group=None):
	"""
	Filters a the GWAS catalog post processing with format_catalog based on a specified trait group such as alcohol, nicotine, substance use disorders (SUD), or neuropsychiatric conditions, returning a subset of the DataFrame. Each category has specific keywords that determine which records from the 'cat' DataFrame are retained. These keywords reflect common characteristics associated with each category in genomic or epidemiological studies.

	Parameters:
	- cat (DataFrame): Pandas DataFrame containing trait data. Expected to have at least a 'TRAIT' column. Presumed to be output from format_catalog.
	- trait_group (str): Category for filtering. Supported values are 'alcohol', 'nicotine', 'SUD', 'neuropsych'.

	Returns:
	DataFrame: A subset of the original DataFrame filtered by the specified trait group.

	Raises:
	- ValueError: If 'trait_group' is not one of the specified categories or if 'cat' is not a DataFrame.

	Notes:
	- Each trait group uses specific keywords to include or exclude rows based on the 'TRAIT' column in 'cat'. All traits are mutually exclusive. Alcohol traits take precident over other SUD traits.

	"""
	if (trait_group=='alcohol'):
		cat=cat[(cat['TRAIT'].str.contains('alcohol'))
			|(cat['TRAIT'].str.contains('drinking'))
		   |(cat['TRAIT'].str.contains('wine'))
		   |(cat['TRAIT'].str.contains('liquor'))
		   |(cat['TRAIT'].str.contains('beer'))]
		#include every measure- could also remove add wine, beer, liquor-doesnt change number of genes
		cat=cat[~(cat['TRAIT'].str.contains('nonalcohol'))]
		cat=cat[~(cat['TRAIT'].str.contains('non-alcohol'))]
	elif(trait_group=='nicotine'):
		cat=cat[(cat['TRAIT'].str.contains('smok'))&(~cat['TRAIT'].str.contains('taste'))]
	elif(trait_group=='SUD'):
		cat=cat[
		(cat['TRAIT'].str.contains('substance')
		|cat['TRAIT'].str.contains('addiction')
		|cat['TRAIT'].str.contains('cocaine')
		|cat['TRAIT'].str.contains('opioid')
		|cat['TRAIT'].str.contains('cannabis')
		|cat['TRAIT'].str.contains('hallucinogen')
		|cat['TRAIT'].str.contains('abuse')
		|cat['TRAIT'].str.contains('dependence'))
		&
		((~cat['TRAIT'].str.contains('externalizing'))
		&(~cat['TRAIT'].str.contains('food'))
		&(~cat['TRAIT'].str.contains('internet'))
		&(~cat['TRAIT'].str.contains('taste'))
		&(~cat['TRAIT'].str.contains('eating'))
		&(~cat['TRAIT'].str.contains('nicotine'))
		&(~cat['TRAIT'].str.contains('alcohol'))
		&(~cat['TRAIT'].str.contains('response to opioid')))
		]
	elif(trait_group=='neuropsych'):
		alc_cat=subset_catalog(cat, 'alcohol')['TRAIT'].to_list()
		smok_cat=subset_catalog(cat, 'nicotine')['TRAIT'].to_list()
		SUD_cat=subset_catalog(cat, 'SUD')['TRAIT'].to_list()
		SUD_inclusive=set(alc_cat+smok_cat+SUD_cat)
		behav_ls=set(cat[
				((cat['TRAIT'].str.contains('depre'))|
				    (cat['TRAIT'].str.contains('neurotic'))|
				    (cat['TRAIT'].str.contains('cogn'))|
				    (cat['TRAIT'].str.contains('behav'))|
				    (cat['TRAIT'].str.contains('anorex'))|
				    ((cat['TRAIT'].str.contains('mani'))&(~cat['TRAIT'].str.contains('holdemania')))|
				    (cat['TRAIT'].str.contains('parkinson'))|
				    (cat['TRAIT'].str.contains('alzheim'))|
				    (cat['TRAIT'].str.contains('feeling'))|
				    (cat['TRAIT'].str.contains('language'))|
				    (cat['TRAIT'].str.contains('schizo'))|
				    (cat['TRAIT'].str.contains('risk'))|
				    (cat['TRAIT'].str.contains('demen'))|
				    (cat['TRAIT'].str.contains('autis'))|
				    (cat['MAPPED_TRAIT'].str.contains('risk'))|
				    (cat['TRAIT'].str.contains('anxiet'))|
				    (cat['TRAIT'].str.contains('memory')&(~cat['TRAIT'].str.contains('cell')))|
				    (cat['TRAIT'].str.contains('externalizing')))
				             &
				    (~cat['TRAIT'].str.contains('cancer')
				     & ~cat['TRAIT'].str.contains('protein')
				     & ~cat['TRAIT'].str.contains('blood pressure')
				     & ~cat['TRAIT'].str.contains('renal')
				     & ~cat['TRAIT'].str.contains('diabete')
				     & ~cat['TRAIT'].str.contains('allergen')
				     & ~cat['TRAIT'].str.contains('radiation')
				     & ~cat['TRAIT'].str.contains('cardio')
				     & ~cat['TRAIT'].str.contains('visceral')
				    )]['TRAIT'])
		behav_ls=behav_ls.difference(set(SUD_inclusive))
		cat=cat[cat['TRAIT'].isin(behav_ls)]
	else:
		print('trait not in list. please provide trait group that matches criteria')
	return(cat)

def format_subset_cat(cat):
    """
    Aggregates and formats a DataFrame by grouping on the 'GENE' column and consolidating the 'TRAIT' values into a set for each gene.
    
    Parameters:
    - cat (DataFrame): A pandas DataFrame with at least two columns, 'GENE' and 'TRAIT'. The 'GENE' column is used
                       to group the data, and 'TRAIT' contains categorical data to be aggregated.

    Returns:
    DataFrame: A new DataFrame with two columns: 'GENE' and 'TRAIT'. Each 'GENE' entry is unique, and 'TRAIT' contains
               a set of traits associated with that gene.

    """
    cat=cat.groupby('GENE').agg(tuple).applymap(set).reset_index()
    cat=cat[['GENE','TRAIT']]
    return(cat)

def venn_rare_test(t1, t2, t3, labels,colors,savefig=False):
    """
    Creates a Venn diagram to visually display overlap of genes identified from 3 sources.

    Parameters:
    - t1 (set): The first set of elements.
    - t2 (set): The second set of elements.
    - t3 (set): The third set of elements.
    - labels (tuple of str): A tuple containing the labels for the three sets. Example: ('Set1', 'Set2', 'Set3')
    - colors (tuple of str): A tuple containing the colors for the three circles in the Venn diagram.
    - savefig (bool, optional): If True, saves the plot as an SVG file. Defaults to False.

    Returns:
    None

    Notes:
    - The order of sets t1, t2, t3 should correspond to the order in labels and colors.
    - This function relies on the matplotlib_venn library to generate Venn diagrams.
    """
    only_t1 = len(t1 - t2 - t3)
    only_t2 = len(t2 - t1 - t3)
    only_t3 = len(t3 - t1 - t2)
    
    only_t1_t2 = len(t1 & t2 - t3)
    only_t1_t3 = len(t1 & t3 - t2)
    only_t2_t3 = len(t2 & t3 - t1)

    t1_t2_t3 = len(t1 & t2 & t3)
    venn3(subsets=(only_t1, only_t2, only_t1_t2, only_t3, only_t1_t3, only_t2_t3, t1_t2_t3), set_labels=labels,set_colors=colors,alpha=.6)
    if savefig:
        plt.savefig('figures/' + 'venn_rare_genes_test'+'.svg',bbox_inches='tight')
    plt.show()

